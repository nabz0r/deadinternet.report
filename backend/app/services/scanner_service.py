"""
URL Scanner Service - powered by Claude AI.

Fetches a URL's content, sends it to Claude for analysis,
and returns a structured AI probability assessment.
"""

import re
import json
import time
import httpx
import anthropic
from app.core.config import settings

SCANNER_PROMPT = """You are an AI content detector. Analyze the following web page content
and determine the likelihood it was generated by AI (LLM).

Evaluate based on:
1. Writing patterns (repetitive structures, generic phrasing, lack of personal voice)
2. Content depth (surface-level vs genuine expertise)
3. Stylistic markers (overuse of transitions, listicle format, filler phrases)
4. Factual specificity (vague claims vs concrete details with sources)
5. Human indicators (personal anecdotes, humor, typos, informal language)

Respond with ONLY a JSON object (no markdown, no backticks):
{
  "ai_probability": <float 0.0-1.0>,
  "verdict": "<human|mixed|ai_generated>",
  "analysis": "<2-3 sentence explanation>",
  "signals": ["<list of specific signals detected>"]
}

Content to analyze:
"""


class ScannerService:
    """Handles URL fetching and AI analysis."""

    def __init__(self):
        self._client: anthropic.AsyncAnthropic | None = None
        self._http: httpx.AsyncClient | None = None

    @property
    def client(self) -> anthropic.AsyncAnthropic:
        if not self._client:
            self._client = anthropic.AsyncAnthropic(api_key=settings.anthropic_api_key)
        return self._client

    @property
    def http(self) -> httpx.AsyncClient:
        if not self._http:
            self._http = httpx.AsyncClient(
                timeout=15.0,
                follow_redirects=True,
                headers={"User-Agent": "DeadInternetReport/1.0 (content-analyzer)"},
            )
        return self._http

    async def fetch_content(self, url: str) -> str:
        """Fetch and extract text content from URL."""
        response = await self.http.get(str(url))
        response.raise_for_status()

        text = response.text
        # Remove script/style blocks
        text = re.sub(r'<script[^>]*>.*?</script>', '', text, flags=re.DOTALL)
        text = re.sub(r'<style[^>]*>.*?</style>', '', text, flags=re.DOTALL)
        text = re.sub(r'<[^>]+>', ' ', text)
        text = re.sub(r'\s+', ' ', text).strip()

        # Limit to ~4000 chars for Claude context
        return text[:4000]

    async def analyze(self, url: str) -> dict:
        """Full scan pipeline: fetch URL -> analyze with Claude -> return result."""
        start = time.monotonic()

        content = await self.fetch_content(url)
        snippet = content[:500]

        message = await self.client.messages.create(
            model=settings.scanner_model,
            max_tokens=500,
            messages=[{
                "role": "user",
                "content": f"{SCANNER_PROMPT}\n---\n{content}",
            }],
        )

        raw = message.content[0].text
        # Strip markdown backticks if Claude adds them anyway
        raw = re.sub(r'^```json\s*', '', raw)
        raw = re.sub(r'\s*```$', '', raw)
        result = json.loads(raw)

        duration_ms = int((time.monotonic() - start) * 1000)

        return {
            "ai_probability": result.get("ai_probability", 0.5),
            "verdict": result.get("verdict", "mixed"),
            "analysis": result.get("analysis", ""),
            "content_snippet": snippet,
            "model_used": settings.scanner_model,
            "tokens_used": message.usage.input_tokens + message.usage.output_tokens,
            "scan_duration_ms": duration_ms,
        }


scanner_service = ScannerService()
